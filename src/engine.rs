use std::collections::{BTreeMap, HashMap};
use std::cmp::Reverse;
use crate::types::{Order, OrderId, OrderType, Price, Qty, Side, Trade};
use crate::error::{EngineError, EngineResult};
use crate::queue::QueueDiscipline;
use crate::time::now_ns;
use serde::{Deserialize, Serialize};

/// Market data snapshot for visualization and analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BookLevelPoint {
    pub price: Price,
    pub qty: Qty,
    pub latency_ms: u64,  // For heatmap visualization
}

/// Comprehensive market data snapshot
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DepthSnapshot {
    pub ts: u128,
    pub best_bid: Option<Price>,
    pub best_ask: Option<Price>,
    pub spread: Option<i64>,
    pub mid: Option<f64>,
    pub bids: Vec<BookLevelPoint>,
    pub asks: Vec<BookLevelPoint>,
}

/// Trait defining the core order book engine interface
/// 
/// This trait abstracts the order book implementation, allowing for different
/// matching engines while maintaining a consistent API for order operations.
pub trait OrderBookEngine {
    /// Place a new order in the book
    /// 
    /// # Arguments
    /// * `order` - The order to place
    /// 
    /// # Returns
    /// * Vector of trades generated by this order (empty if no matches)
    /// 
    /// # Errors
    /// * `InvalidPrice` - For limit orders with invalid prices
    /// * `InvalidQty` - For orders with zero or negative quantity
    /// * `NoLiquidity` - For market orders when no opposite side exists
    /// * `Reject` - For business logic rejections
    fn place(&mut self, order: Order) -> EngineResult<Vec<Trade>>;

    /// Cancel an existing order
    /// 
    /// # Arguments
    /// * `order_id` - ID of the order to cancel
    /// 
    /// # Returns
    /// * Quantity that was cancelled
    /// 
    /// # Errors
    /// * `UnknownOrder` - If the order ID is not found
    fn cancel(&mut self, order_id: OrderId) -> EngineResult<Qty>;

    /// Get the best bid price
    /// 
    /// # Returns
    /// * Some(price) if there are any bid orders, None otherwise
    fn best_bid(&self) -> Option<Price>;

    /// Get the best ask price
    /// 
    /// # Returns
    /// * Some(price) if there are any ask orders, None otherwise
    fn best_ask(&self) -> Option<Price>;

    /// Get the total quantity available at a specific price level
    /// 
    /// # Arguments
    /// * `side` - Which side of the book to query
    /// * `price` - The price level to query
    /// 
    /// # Returns
    /// * Total quantity available at that price level (0 if no orders)
    fn depth_at(&self, side: Side, price: Price) -> Qty;

    /// Generate a complete market data snapshot
    /// 
    /// # Returns
    /// * DepthSnapshot containing current market state
    fn snapshot(&self) -> DepthSnapshot;

    /// Get the current spread (ask - bid)
    /// 
    /// # Returns
    /// * Some(spread) if both bid and ask exist, None otherwise
    fn spread(&self) -> Option<i64> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some(ask as i64 - bid as i64),
            _ => None,
        }
    }

    /// Get the current mid-price
    /// 
    /// # Returns
    /// * Some(mid_price) if both bid and ask exist, None otherwise
    fn mid_price(&self) -> Option<f64> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some((bid as f64 + ask as f64) / 2.0 / 10000.0),
            _ => None,
        }
    }
}

/// Generic order book implementation using pluggable queue disciplines
/// 
/// The order book maintains price levels using BTreeMap for efficient price-ordered
/// access, and uses a HashMap for O(1) order lookup during cancellations.
/// 
/// # Type Parameters
/// * `D` - Queue discipline implementation (e.g., FifoLevel, ProRataLevel)
pub struct OrderBook<D: QueueDiscipline> {
    /// Bid side: price levels in descending order (best bid first)
    /// Uses Reverse wrapper to get descending order from BTreeMap
    bids: BTreeMap<Reverse<Price>, D>,
    
    /// Ask side: price levels in ascending order (best ask first)
    asks: BTreeMap<Price, D>,
    
    /// Order index for fast cancellation lookup
    /// Maps order_id -> (side, price) for O(1) order location
    order_index: HashMap<OrderId, (Side, Price)>,
    
    /// Function to create new queue discipline instances
    level_factory: fn() -> D,
}

impl<D: QueueDiscipline + Default> OrderBook<D> {
    /// Create a new order book with default level factory
    pub fn new() -> Self {
        Self::with_level_factory(D::default)
    }
}

impl<D: QueueDiscipline> OrderBook<D> {
    /// Create a new order book with custom level factory
    /// 
    /// # Arguments
    /// * `level_factory` - Function to create new queue discipline instances
    pub fn with_level_factory(level_factory: fn() -> D) -> Self {
        Self {
            bids: BTreeMap::new(),
            asks: BTreeMap::new(),
            order_index: HashMap::new(),
            level_factory,
        }
    }

    /// Validate an order before processing
    fn validate_order(&self, order: &Order) -> EngineResult<()> {
        // Check quantity
        if order.qty == 0 {
            return Err(EngineError::InvalidQty { qty: order.qty });
        }

        // Check price for limit orders
        if let OrderType::Limit { price } = order.order_type {
            if price == 0 {
                return Err(EngineError::InvalidPrice { price });
            }
        }

        // Check for duplicate order ID
        if self.order_index.contains_key(&order.id) {
            return Err(EngineError::reject(format!(
                "Order ID {} already exists", order.id
            )));
        }

        Ok(())
    }

    /// Process a limit order by crossing against opposite side
    fn process_limit_order(&mut self, mut order: Order, limit_price: Price) -> EngineResult<Vec<Trade>> {
        let mut trades = Vec::new();
        
        // Cross against opposite side levels based on order side
        match order.side {
            Side::Buy => {
                // Buy order crosses against asks (ascending price order)
                let mut prices_to_remove = Vec::new();
                
                for (price, level) in self.asks.iter_mut() {
                    // Check if we can cross at this price (buy crosses if ask <= bid_limit)
                    if *price > limit_price {
                        break; // No more crossable levels (asks are in ascending order)
                    }

                    // Match against this level
                    let (remaining_qty, level_trades) = level.match_against(
                        order.id,
                        order.side,
                        order.qty,
                        *price,
                    );

                    trades.extend(level_trades);
                    order.qty = remaining_qty;

                    // Mark level for removal if empty
                    if level.is_empty() {
                        prices_to_remove.push(*price);
                    }

                    // Stop if order is fully filled
                    if order.qty == 0 {
                        break;
                    }
                }

                // Remove empty levels
                for price in prices_to_remove {
                    self.asks.remove(&price);
                }
            }
            Side::Sell => {
                // Sell order crosses against bids (descending price order)
                let mut prices_to_remove = Vec::new();
                
                for (reverse_price, level) in self.bids.iter_mut() {
                    let price = reverse_price.0;
                    
                    // Check if we can cross at this price (sell crosses if bid >= ask_limit)
                    if price < limit_price {
                        break; // No more crossable levels (bids are in descending order)
                    }

                    // Match against this level
                    let (remaining_qty, level_trades) = level.match_against(
                        order.id,
                        order.side,
                        order.qty,
                        price,
                    );

                    trades.extend(level_trades);
                    order.qty = remaining_qty;

                    // Mark level for removal if empty
                    if level.is_empty() {
                        prices_to_remove.push(*reverse_price);
                    }

                    // Stop if order is fully filled
                    if order.qty == 0 {
                        break;
                    }
                }

                // Remove empty levels
                for reverse_price in prices_to_remove {
                    self.bids.remove(&reverse_price);
                }
            }
        }

        // Add remaining quantity to our side if any
        if order.qty > 0 {
            self.add_to_book(order, limit_price)?;
        }

        Ok(trades)
    }

    /// Process a market order by crossing against opposite side at any price
    fn process_market_order(&mut self, mut order: Order) -> EngineResult<Vec<Trade>> {
        let mut trades = Vec::new();
        
        // Cross against opposite side levels based on order side
        match order.side {
            Side::Buy => {
                // Market buy crosses against asks (best ask first)
                if self.asks.is_empty() {
                    return Err(EngineError::NoLiquidity);
                }

                let mut prices_to_remove = Vec::new();
                
                for (price, level) in self.asks.iter_mut() {
                    // Match against this level
                    let (remaining_qty, level_trades) = level.match_against(
                        order.id,
                        order.side,
                        order.qty,
                        *price,
                    );

                    trades.extend(level_trades);
                    order.qty = remaining_qty;

                    // Mark level for removal if empty
                    if level.is_empty() {
                        prices_to_remove.push(*price);
                    }

                    // Stop if order is fully filled
                    if order.qty == 0 {
                        break;
                    }
                }

                // Remove empty levels
                for price in prices_to_remove {
                    self.asks.remove(&price);
                }
            }
            Side::Sell => {
                // Market sell crosses against bids (best bid first)
                if self.bids.is_empty() {
                    return Err(EngineError::NoLiquidity);
                }

                let mut prices_to_remove = Vec::new();
                
                for (reverse_price, level) in self.bids.iter_mut() {
                    let price = reverse_price.0;
                    
                    // Match against this level
                    let (remaining_qty, level_trades) = level.match_against(
                        order.id,
                        order.side,
                        order.qty,
                        price,
                    );

                    trades.extend(level_trades);
                    order.qty = remaining_qty;

                    // Mark level for removal if empty
                    if level.is_empty() {
                        prices_to_remove.push(*reverse_price);
                    }

                    // Stop if order is fully filled
                    if order.qty == 0 {
                        break;
                    }
                }

                // Remove empty levels
                for reverse_price in prices_to_remove {
                    self.bids.remove(&reverse_price);
                }
            }
        }

        // Market orders don't rest in the book - any unfilled quantity is lost
        if order.qty > 0 {
            return Err(EngineError::reject(format!(
                "Market order partially filled: {} shares unfilled", order.qty
            )));
        }

        Ok(trades)
    }

    /// Add an order to the appropriate side of the book
    fn add_to_book(&mut self, order: Order, price: Price) -> EngineResult<()> {
        // Add to order index
        self.order_index.insert(order.id, (order.side, price));

        // Add to appropriate side
        match order.side {
            Side::Buy => {
                let level = self.bids.entry(Reverse(price)).or_insert_with(&self.level_factory);
                level.enqueue(order);
            }
            Side::Sell => {
                let level = self.asks.entry(price).or_insert_with(&self.level_factory);
                level.enqueue(order);
            }
        }

        Ok(())
    }

    /// Calculate latency in milliseconds for visualization
    fn calculate_latency_ms(&self, last_activity_ts: u128) -> u64 {
        let current_ts = now_ns();
        let latency_ns = current_ts.saturating_sub(last_activity_ts);
        (latency_ns / 1_000_000).min(u64::MAX as u128) as u64
    }
}

impl<D: QueueDiscipline> OrderBookEngine for OrderBook<D> {
    fn place(&mut self, order: Order) -> EngineResult<Vec<Trade>> {
        // Validate the order
        self.validate_order(&order)?;

        // Process based on order type
        match order.order_type {
            OrderType::Limit { price } => self.process_limit_order(order, price),
            OrderType::Market => self.process_market_order(order),
        }
    }

    fn cancel(&mut self, order_id: OrderId) -> EngineResult<Qty> {
        // Look up order in index
        let (side, price) = self.order_index.remove(&order_id)
            .ok_or(EngineError::UnknownOrder { order_id })?;

        // Cancel from appropriate side
        let cancelled_qty = match side {
            Side::Buy => {
                let level = self.bids.get_mut(&Reverse(price))
                    .ok_or(EngineError::internal("Order index inconsistency: bid level not found"))?;
                
                let qty = level.cancel(order_id);
                
                // Remove level if empty
                if level.is_empty() {
                    self.bids.remove(&Reverse(price));
                }
                
                qty
            }
            Side::Sell => {
                let level = self.asks.get_mut(&price)
                    .ok_or(EngineError::internal("Order index inconsistency: ask level not found"))?;
                
                let qty = level.cancel(order_id);
                
                // Remove level if empty
                if level.is_empty() {
                    self.asks.remove(&price);
                }
                
                qty
            }
        };

        if cancelled_qty == 0 {
            return Err(EngineError::UnknownOrder { order_id });
        }

        Ok(cancelled_qty)
    }

    fn best_bid(&self) -> Option<Price> {
        self.bids.keys().next().map(|reverse_price| reverse_price.0)
    }

    fn best_ask(&self) -> Option<Price> {
        self.asks.keys().next().copied()
    }

    fn depth_at(&self, side: Side, price: Price) -> Qty {
        match side {
            Side::Buy => {
                self.bids.get(&Reverse(price))
                    .map(|level| level.total_qty())
                    .unwrap_or(0)
            }
            Side::Sell => {
                self.asks.get(&price)
                    .map(|level| level.total_qty())
                    .unwrap_or(0)
            }
        }
    }

    fn snapshot(&self) -> DepthSnapshot {
        let ts = now_ns();
        let best_bid = self.best_bid();
        let best_ask = self.best_ask();
        let spread = self.spread();
        let mid = self.mid_price();

        // Collect bid levels (already in descending price order)
        let bids: Vec<BookLevelPoint> = self.bids
            .iter()
            .map(|(reverse_price, level)| BookLevelPoint {
                price: reverse_price.0,
                qty: level.total_qty(),
                latency_ms: self.calculate_latency_ms(level.last_ts()),
            })
            .collect();

        // Collect ask levels (already in ascending price order)
        let asks: Vec<BookLevelPoint> = self.asks
            .iter()
            .map(|(price, level)| BookLevelPoint {
                price: *price,
                qty: level.total_qty(),
                latency_ms: self.calculate_latency_ms(level.last_ts()),
            })
            .collect();

        DepthSnapshot {
            ts,
            best_bid,
            best_ask,
            spread,
            mid,
            bids,
            asks,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::queue_fifo::FifoLevel;
    use crate::types::{OrderType, Side};
    use crate::time::now_ns;

    type TestOrderBook = OrderBook<FifoLevel>;

    fn create_test_order(id: OrderId, side: Side, qty: Qty, order_type: OrderType) -> Order {
        Order {
            id,
            side,
            qty,
            order_type,
            ts: now_ns(),
        }
    }

    #[test]
    fn test_order_book_creation() {
        let book = TestOrderBook::new();
        assert_eq!(book.best_bid(), None);
        assert_eq!(book.best_ask(), None);
        assert_eq!(book.spread(), None);
        assert_eq!(book.mid_price(), None);
    }

    #[test]
    fn test_place_limit_orders() {
        let mut book = TestOrderBook::new();
        
        // Place a buy order (price 50.00 = 500000 ticks)
        let buy_order = create_test_order(1, Side::Buy, 100, OrderType::Limit { price: 500000 });
        let trades = book.place(buy_order).unwrap();
        assert!(trades.is_empty()); // No crossing
        assert_eq!(book.best_bid(), Some(500000));
        assert_eq!(book.best_ask(), None);
        
        // Place a sell order at higher price (no crossing) (price 51.00 = 510000 ticks)
        let sell_order = create_test_order(2, Side::Sell, 200, OrderType::Limit { price: 510000 });
        let trades = book.place(sell_order).unwrap();
        assert!(trades.is_empty()); // No crossing
        assert_eq!(book.best_bid(), Some(500000));
        assert_eq!(book.best_ask(), Some(510000));
        assert_eq!(book.spread(), Some(10000)); // 1.00 in ticks
        assert_eq!(book.mid_price(), Some(50.5));
    }

    #[test]
    fn test_order_crossing() {
        let mut book = TestOrderBook::new();
        
        // Place a buy order
        let buy_order = create_test_order(1, Side::Buy, 100, OrderType::Limit { price: 500000 });
        book.place(buy_order).unwrap();
        
        // Place a sell order that crosses
        let sell_order = create_test_order(2, Side::Sell, 50, OrderType::Limit { price: 495000 });
        let trades = book.place(sell_order).unwrap();
        
        // Should generate one trade
        assert_eq!(trades.len(), 1);
        assert_eq!(trades[0].maker_id, 1);
        assert_eq!(trades[0].taker_id, 2);
        assert_eq!(trades[0].price, 500000); // Trade at maker's price
        assert_eq!(trades[0].qty, 50);
        
        // Buy order should have 50 remaining
        assert_eq!(book.depth_at(Side::Buy, 500000), 50);
        assert_eq!(book.depth_at(Side::Sell, 495000), 0); // Sell order fully filled
    }

    #[test]
    fn test_market_order_buy() {
        let mut book = TestOrderBook::new();
        
        // Place some sell orders
        let sell1 = create_test_order(1, Side::Sell, 100, OrderType::Limit { price: 500000 });
        let sell2 = create_test_order(2, Side::Sell, 200, OrderType::Limit { price: 510000 });
        book.place(sell1).unwrap();
        book.place(sell2).unwrap();
        
        // Place market buy order
        let market_buy = create_test_order(3, Side::Buy, 150, OrderType::Market);
        let trades = book.place(market_buy).unwrap();
        
        // Should generate 2 trades
        assert_eq!(trades.len(), 2);
        
        // First trade at 500000 for 100 shares
        assert_eq!(trades[0].maker_id, 1);
        assert_eq!(trades[0].taker_id, 3);
        assert_eq!(trades[0].price, 500000);
        assert_eq!(trades[0].qty, 100);
        
        // Second trade at 510000 for 50 shares
        assert_eq!(trades[1].maker_id, 2);
        assert_eq!(trades[1].taker_id, 3);
        assert_eq!(trades[1].price, 510000);
        assert_eq!(trades[1].qty, 50);
        
        // Check remaining quantities
        assert_eq!(book.depth_at(Side::Sell, 500000), 0); // First level consumed
        assert_eq!(book.depth_at(Side::Sell, 510000), 150); // 200 - 50 = 150 remaining
        assert_eq!(book.best_ask(), Some(510000));
    }

    #[test]
    fn test_market_order_no_liquidity() {
        let mut book = TestOrderBook::new();
        
        // Try to place market buy with no asks
        let market_buy = create_test_order(1, Side::Buy, 100, OrderType::Market);
        let result = book.place(market_buy);
        
        assert!(matches!(result, Err(EngineError::NoLiquidity)));
    }

    #[test]
    fn test_order_cancellation() {
        let mut book = TestOrderBook::new();
        
        // Place some orders
        let buy1 = create_test_order(1, Side::Buy, 100, OrderType::Limit { price: 500000 });
        let buy2 = create_test_order(2, Side::Buy, 200, OrderType::Limit { price: 495000 });
        let sell1 = create_test_order(3, Side::Sell, 150, OrderType::Limit { price: 510000 });
        
        book.place(buy1).unwrap();
        book.place(buy2).unwrap();
        book.place(sell1).unwrap();
        
        // Cancel middle buy order
        let cancelled_qty = book.cancel(2).unwrap();
        assert_eq!(cancelled_qty, 200);
        
        // Check that best bid is now the remaining order
        assert_eq!(book.best_bid(), Some(500000));
        assert_eq!(book.depth_at(Side::Buy, 495000), 0);
        assert_eq!(book.depth_at(Side::Buy, 500000), 100);
        
        // Try to cancel non-existent order
        let result = book.cancel(999);
        assert!(matches!(result, Err(EngineError::UnknownOrder { order_id: 999 })));
    }

    #[test]
    fn test_order_validation() {
        let mut book = TestOrderBook::new();
        
        // Test zero quantity
        let zero_qty_order = create_test_order(1, Side::Buy, 0, OrderType::Limit { price: 500000 });
        let result = book.place(zero_qty_order);
        assert!(matches!(result, Err(EngineError::InvalidQty { qty: 0 })));
        
        // Test zero price for limit order
        let zero_price_order = create_test_order(2, Side::Buy, 100, OrderType::Limit { price: 0 });
        let result = book.place(zero_price_order);
        assert!(matches!(result, Err(EngineError::InvalidPrice { price: 0 })));
        
        // Test duplicate order ID
        let order1 = create_test_order(3, Side::Buy, 100, OrderType::Limit { price: 500000 });
        let order2 = create_test_order(3, Side::Sell, 200, OrderType::Limit { price: 510000 });
        
        book.place(order1).unwrap();
        let result = book.place(order2);
        assert!(matches!(result, Err(EngineError::Reject { .. })));
    }

    #[test]
    fn test_depth_snapshot() {
        let mut book = TestOrderBook::new();
        
        // Place orders on both sides (using proper tick values)
        let buy1 = create_test_order(1, Side::Buy, 100, OrderType::Limit { price: 500000 }); // $50.00
        let buy2 = create_test_order(2, Side::Buy, 200, OrderType::Limit { price: 495000 }); // $49.50
        let sell1 = create_test_order(3, Side::Sell, 150, OrderType::Limit { price: 510000 }); // $51.00
        let sell2 = create_test_order(4, Side::Sell, 300, OrderType::Limit { price: 520000 }); // $52.00
        
        book.place(buy1).unwrap();
        book.place(buy2).unwrap();
        book.place(sell1).unwrap();
        book.place(sell2).unwrap();
        
        let snapshot = book.snapshot();
        
        // Check basic market data
        assert_eq!(snapshot.best_bid, Some(500000));
        assert_eq!(snapshot.best_ask, Some(510000));
        assert_eq!(snapshot.spread, Some(10000)); // $1.00 in ticks
        assert_eq!(snapshot.mid, Some(50.5));
        
        // Check bid levels (should be in descending price order)
        assert_eq!(snapshot.bids.len(), 2);
        assert_eq!(snapshot.bids[0].price, 500000);
        assert_eq!(snapshot.bids[0].qty, 100);
        assert_eq!(snapshot.bids[1].price, 495000);
        assert_eq!(snapshot.bids[1].qty, 200);
        
        // Check ask levels (should be in ascending price order)
        assert_eq!(snapshot.asks.len(), 2);
        assert_eq!(snapshot.asks[0].price, 510000);
        assert_eq!(snapshot.asks[0].qty, 150);
        assert_eq!(snapshot.asks[1].price, 520000);
        assert_eq!(snapshot.asks[1].qty, 300);
    }

    #[test]
    fn test_multiple_level_crossing() {
        let mut book = TestOrderBook::new();
        
        // Place multiple ask levels
        let sell1 = create_test_order(1, Side::Sell, 100, OrderType::Limit { price: 500000 });
        let sell2 = create_test_order(2, Side::Sell, 200, OrderType::Limit { price: 510000 });
        let sell3 = create_test_order(3, Side::Sell, 150, OrderType::Limit { price: 520000 });
        
        book.place(sell1).unwrap();
        book.place(sell2).unwrap();
        book.place(sell3).unwrap();
        
        // Place large buy order that crosses multiple levels
        let big_buy = create_test_order(4, Side::Buy, 250, OrderType::Limit { price: 515000 });
        let trades = book.place(big_buy).unwrap();
        
        // Should generate 2 trades (crosses first two levels)
        assert_eq!(trades.len(), 2);
        
        // First trade at 500000 for 100 shares
        assert_eq!(trades[0].price, 500000);
        assert_eq!(trades[0].qty, 100);
        
        // Second trade at 510000 for 150 shares (remaining taker qty)
        assert_eq!(trades[1].price, 510000);
        assert_eq!(trades[1].qty, 150);
        
        // Check remaining state
        assert_eq!(book.depth_at(Side::Sell, 500000), 0); // Fully consumed
        assert_eq!(book.depth_at(Side::Sell, 510000), 50); // 200 - 150 = 50 remaining
        assert_eq!(book.depth_at(Side::Sell, 520000), 150); // Untouched
        assert_eq!(book.best_ask(), Some(510000));
    }
}