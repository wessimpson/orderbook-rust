use std::collections::{BTreeMap, HashMap};
use std::cmp::Reverse;
use std::sync::Arc;
use std::time::Instant;
use crate::types::{Order, OrderId, OrderType, Price, Qty, Side, Trade};
use crate::error::{EngineError, EngineResult};
use crate::queue::QueueDiscipline;
use crate::time::now_ns;
use crate::metrics::PerformanceMetrics;
use crate::memory::CircularBuffer;
use serde::{Deserialize, Serialize};

/// Market data snapshot for visualization and analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BookLevelPoint {
    pub price: Price,
    pub qty: Qty,
    pub latency_ms: u64,  // For heatmap visualization
}

/// Comprehensive market data snapshot
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DepthSnapshot {
    pub ts: u128,
    pub best_bid: Option<Price>,
    pub best_ask: Option<Price>,
    pub spread: Option<i64>,
    pub mid: Option<f64>,
    pub bids: Vec<BookLevelPoint>,
    pub asks: Vec<BookLevelPoint>,
    pub recent_spreads: Vec<(u128, i64)>,
    pub metrics: crate::types::Metrics,
}

/// Trait defining the core order book engine interface
/// 
/// This trait abstracts the order book implementation, allowing for different
/// matching engines while maintaining a consistent API for order operations.
pub trait OrderBookEngine {
    /// Place a new order in the book
    /// 
    /// # Arguments
    /// * `order` - The order to place
    /// 
    /// # Returns
    /// * Vector of trades generated by this order (empty if no matches)
    /// 
    /// # Errors
    /// * `InvalidPrice` - For limit orders with invalid prices
    /// * `InvalidQty` - For orders with zero or negative quantity
    /// * `NoLiquidity` - For market orders when no opposite side exists
    /// * `Reject` - For business logic rejections
    fn place(&mut self, order: Order) -> EngineResult<Vec<Trade>>;

    /// Cancel an existing order
    /// 
    /// # Arguments
    /// * `order_id` - ID of the order to cancel
    /// 
    /// # Returns
    /// * Quantity that was cancelled
    /// 
    /// # Errors
    /// * `UnknownOrder` - If the order ID is not found
    fn cancel(&mut self, order_id: OrderId) -> EngineResult<Qty>;

    /// Get the best bid price
    /// 
    /// # Returns
    /// * Some(price) if there are any bid orders, None otherwise
    fn best_bid(&self) -> Option<Price>;

    /// Get the best ask price
    /// 
    /// # Returns
    /// * Some(price) if there are any ask orders, None otherwise
    fn best_ask(&self) -> Option<Price>;

    /// Get the total quantity available at a specific price level
    /// 
    /// # Arguments
    /// * `side` - Which side of the book to query
    /// * `price` - The price level to query
    /// 
    /// # Returns
    /// * Total quantity available at that price level (0 if no orders)
    fn depth_at(&self, side: Side, price: Price) -> Qty;

    /// Generate a complete market data snapshot
    /// 
    /// # Returns
    /// * DepthSnapshot containing current market state
    fn snapshot(&self) -> DepthSnapshot;

    /// Get the current spread (ask - bid)
    /// 
    /// # Returns
    /// * Some(spread) if both bid and ask exist, None otherwise
    fn spread(&self) -> Option<i64> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some(ask as i64 - bid as i64),
            _ => None,
        }
    }

    /// Get the current mid-price
    /// 
    /// # Returns
    /// * Some(mid_price) if both bid and ask exist, None otherwise
    fn mid_price(&self) -> Option<f64> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some((bid as f64 + ask as f64) / 2.0 / 10000.0),
            _ => None,
        }
    }
}

/// Generic order book implementation using pluggable queue disciplines
/// 
/// The order book maintains price levels using BTreeMap for efficient price-ordered
/// access, and uses a HashMap for O(1) order lookup during cancellations.
/// 
/// # Type Parameters
/// * `D` - Queue discipline implementation (e.g., FifoLevel, ProRataLevel)
pub struct OrderBook<D: QueueDiscipline> {
    /// Bid side: price levels in descending order (best bid first)
    /// Uses Reverse wrapper to get descending order from BTreeMap
    bids: BTreeMap<Reverse<Price>, D>,
    
    /// Ask side: price levels in ascending order (best ask first)
    asks: BTreeMap<Price, D>,
    
    /// Order index for fast cancellation lookup
    /// Maps order_id -> (side, price) for O(1) order location
    order_index: HashMap<OrderId, (Side, Price)>,
    
    /// Function to create new queue discipline instances
    level_factory: fn() -> D,
    
    /// Rolling history of spread values for visualization
    /// Tuple format: (timestamp, spread_in_ticks)
    recent_spreads: CircularBuffer<(u128, i64)>,
    
    /// Trading performance metrics
    metrics: crate::types::Metrics,
    
    /// Performance monitoring (optional)
    perf_metrics: Option<Arc<PerformanceMetrics>>,
}

impl<D: QueueDiscipline + Default> OrderBook<D> {
    /// Create a new order book with default level factory
    pub fn new() -> Self {
        Self::with_level_factory(D::default)
    }
}

impl<D: QueueDiscipline> OrderBook<D> {
    /// Create a new order book with custom level factory
    /// 
    /// # Arguments
    /// * `level_factory` - Function to create new queue discipline instances
    pub fn with_level_factory(level_factory: fn() -> D) -> Self {
        Self {
            bids: BTreeMap::new(),
            asks: BTreeMap::new(),
            order_index: HashMap::new(),
            level_factory,
            recent_spreads: CircularBuffer::new(400),
            metrics: crate::types::Metrics::new(),
            perf_metrics: None,
        }
    }

    /// Create a new order book with performance monitoring
    pub fn with_performance_monitoring(level_factory: fn() -> D, perf_metrics: Arc<PerformanceMetrics>) -> Self {
        Self {
            bids: BTreeMap::new(),
            asks: BTreeMap::new(),
            order_index: HashMap::new(),
            level_factory,
            recent_spreads: CircularBuffer::new(400),
            metrics: crate::types::Metrics::new(),
            perf_metrics: Some(perf_metrics),
        }
    }

    /// Validate an order before processing
    fn validate_order(&self, order: &Order) -> EngineResult<()> {
        use crate::logging::log_order_operation;
        
        // Check quantity bounds
        if order.qty == 0 {
            log_order_operation("VALIDATION_FAILED", order.id, Some("Zero quantity"));
            return Err(EngineError::InvalidQty { qty: order.qty });
        }

        // Check maximum quantity limit (prevent overflow and unrealistic orders)
        const MAX_QTY: Qty = 1_000_000_000; // 1 billion shares max
        if order.qty > MAX_QTY {
            log_order_operation("VALIDATION_FAILED", order.id, Some(&format!("Quantity {} exceeds maximum {}", order.qty, MAX_QTY)));
            return Err(EngineError::QtyTooLarge { 
                qty: order.qty, 
                max_qty: MAX_QTY 
            });
        }

        // Check price for limit orders
        if let OrderType::Limit { price } = order.order_type {
            if price == 0 {
                log_order_operation("VALIDATION_FAILED", order.id, Some("Zero price for limit order"));
                return Err(EngineError::InvalidPrice { price });
            }

            // Check price bounds (prevent overflow and unrealistic prices)
            const MIN_PRICE: Price = 1; // Minimum 1 tick
            const MAX_PRICE: Price = 100_000_000; // $10,000 per share max (in ticks)
            
            if price < MIN_PRICE || price > MAX_PRICE {
                log_order_operation("VALIDATION_FAILED", order.id, Some(&format!("Price {} outside valid range [{}, {}]", price, MIN_PRICE, MAX_PRICE)));
                return Err(EngineError::PriceOutOfRange {
                    price,
                    min_price: MIN_PRICE,
                    max_price: MAX_PRICE,
                });
            }
        }

        // Check for duplicate order ID
        if self.order_index.contains_key(&order.id) {
            log_order_operation("VALIDATION_FAILED", order.id, Some("Duplicate order ID"));
            return Err(EngineError::reject(format!(
                "Order ID {} already exists", order.id
            )));
        }

        // Check timestamp is reasonable (not too far in the past or future)
        let current_ts = crate::time::now_ns();
        let one_hour_ns = 3_600_000_000_000u128; // 1 hour in nanoseconds
        
        if order.ts > current_ts + one_hour_ns {
            log_order_operation("VALIDATION_FAILED", order.id, Some("Timestamp too far in future"));
            return Err(EngineError::reject(format!(
                "Order timestamp {} is too far in the future", order.ts
            )));
        }
        
        if current_ts > order.ts + one_hour_ns {
            log_order_operation("VALIDATION_FAILED", order.id, Some("Timestamp too far in past"));
            return Err(EngineError::reject(format!(
                "Order timestamp {} is too far in the past", order.ts
            )));
        }

        log_order_operation("VALIDATION_PASSED", order.id, Some(&format!("{:?} {} @ {:?}", order.side, order.qty, order.order_type)));
        Ok(())
    }

    /// Process a limit order by crossing against opposite side
    fn process_limit_order(&mut self, mut order: Order, limit_price: Price) -> EngineResult<Vec<Trade>> {
        let mut trades = Vec::new();
        
        // Cross against opposite side levels based on order side
        match order.side {
            Side::Buy => {
                // Buy order crosses against asks (ascending price order)
                let mut prices_to_remove = Vec::new();
                
                for (price, level) in self.asks.iter_mut() {
                    // Check if we can cross at this price (buy crosses if ask <= bid_limit)
                    if *price > limit_price {
                        break; // No more crossable levels (asks are in ascending order)
                    }

                    // Match against this level
                    let (remaining_qty, level_trades) = level.match_against(
                        order.id,
                        order.side,
                        order.qty,
                        *price,
                    );

                    trades.extend(level_trades);
                    order.qty = remaining_qty;

                    // Mark level for removal if empty
                    if level.is_empty() {
                        prices_to_remove.push(*price);
                    }

                    // Stop if order is fully filled
                    if order.qty == 0 {
                        break;
                    }
                }

                // Remove empty levels
                for price in prices_to_remove {
                    self.asks.remove(&price);
                }
            }
            Side::Sell => {
                // Sell order crosses against bids (descending price order)
                let mut prices_to_remove = Vec::new();
                
                for (reverse_price, level) in self.bids.iter_mut() {
                    let price = reverse_price.0;
                    
                    // Check if we can cross at this price (sell crosses if bid >= ask_limit)
                    if price < limit_price {
                        break; // No more crossable levels (bids are in descending order)
                    }

                    // Match against this level
                    let (remaining_qty, level_trades) = level.match_against(
                        order.id,
                        order.side,
                        order.qty,
                        price,
                    );

                    trades.extend(level_trades);
                    order.qty = remaining_qty;

                    // Mark level for removal if empty
                    if level.is_empty() {
                        prices_to_remove.push(*reverse_price);
                    }

                    // Stop if order is fully filled
                    if order.qty == 0 {
                        break;
                    }
                }

                // Remove empty levels
                for reverse_price in prices_to_remove {
                    self.bids.remove(&reverse_price);
                }
            }
        }

        // Update metrics for each trade and spread history if trades occurred
        if !trades.is_empty() {
            for trade in &trades {
                self.update_metrics_for_trade(trade, order.side);
            }
            // Update spread history after processing trades
            self.update_spread_history();
        }

        // Add remaining quantity to our side if any
        if order.qty > 0 {
            self.add_to_book(order, limit_price)?;
        }

        Ok(trades)
    }

    /// Process a market order by crossing against opposite side at any price
    fn process_market_order(&mut self, mut order: Order) -> EngineResult<Vec<Trade>> {
        let mut trades = Vec::new();
        
        // Cross against opposite side levels based on order side
        match order.side {
            Side::Buy => {
                // Market buy crosses against asks (best ask first)
                if self.asks.is_empty() {
                    return Err(EngineError::NoLiquidity);
                }

                let mut prices_to_remove = Vec::new();
                
                for (price, level) in self.asks.iter_mut() {
                    // Match against this level
                    let (remaining_qty, level_trades) = level.match_against(
                        order.id,
                        order.side,
                        order.qty,
                        *price,
                    );

                    trades.extend(level_trades);
                    order.qty = remaining_qty;

                    // Mark level for removal if empty
                    if level.is_empty() {
                        prices_to_remove.push(*price);
                    }

                    // Stop if order is fully filled
                    if order.qty == 0 {
                        break;
                    }
                }

                // Remove empty levels
                for price in prices_to_remove {
                    self.asks.remove(&price);
                }
            }
            Side::Sell => {
                // Market sell crosses against bids (best bid first)
                if self.bids.is_empty() {
                    return Err(EngineError::NoLiquidity);
                }

                let mut prices_to_remove = Vec::new();
                
                for (reverse_price, level) in self.bids.iter_mut() {
                    let price = reverse_price.0;
                    
                    // Match against this level
                    let (remaining_qty, level_trades) = level.match_against(
                        order.id,
                        order.side,
                        order.qty,
                        price,
                    );

                    trades.extend(level_trades);
                    order.qty = remaining_qty;

                    // Mark level for removal if empty
                    if level.is_empty() {
                        prices_to_remove.push(*reverse_price);
                    }

                    // Stop if order is fully filled
                    if order.qty == 0 {
                        break;
                    }
                }

                // Remove empty levels
                for reverse_price in prices_to_remove {
                    self.bids.remove(&reverse_price);
                }
            }
        }

        // Update metrics for each trade and spread history if trades occurred
        if !trades.is_empty() {
            for trade in &trades {
                self.update_metrics_for_trade(trade, order.side);
            }
            // Update spread history after processing trades
            self.update_spread_history();
        }

        // Market orders don't rest in the book - any unfilled quantity is lost
        if order.qty > 0 {
            return Err(EngineError::reject(format!(
                "Market order partially filled: {} shares unfilled", order.qty
            )));
        }

        Ok(trades)
    }

    /// Add an order to the appropriate side of the book
    fn add_to_book(&mut self, order: Order, price: Price) -> EngineResult<()> {
        // Add to order index
        self.order_index.insert(order.id, (order.side, price));

        // Add to appropriate side
        match order.side {
            Side::Buy => {
                let level = self.bids.entry(Reverse(price)).or_insert_with(&self.level_factory);
                level.enqueue(order);
            }
            Side::Sell => {
                let level = self.asks.entry(price).or_insert_with(&self.level_factory);
                level.enqueue(order);
            }
        }

        Ok(())
    }

    /// Calculate latency in milliseconds for visualization
    fn calculate_latency_ms(&self, last_activity_ts: u128) -> u64 {
        let current_ts = now_ns();
        let latency_ns = current_ts.saturating_sub(last_activity_ts);
        (latency_ns / 1_000_000).min(u64::MAX as u128) as u64
    }

    /// Update spread history with current spread
    fn update_spread_history(&mut self) {
        if let Some(spread) = self.spread() {
            let ts = now_ns();
            self.recent_spreads.push((ts, spread));
        }
    }

    /// Update metrics after trade execution
    fn update_metrics_for_trade(&mut self, trade: &Trade, taker_side: Side) {
        // Update metrics based on the taker's perspective
        self.metrics.update_trade(taker_side, trade.qty, trade.price);
        
        // Calculate PnL using current mid-price
        let mid_price_ticks = self.mid_price().map(|mid| (mid * 10000.0) as Price);
        self.metrics.calculate_pnl(mid_price_ticks);
    }

    /// Get a copy of recent spreads for snapshot
    fn get_recent_spreads(&self) -> Vec<(u128, i64)> {
        self.recent_spreads.to_vec()
    }

    /// Get current metrics
    pub fn get_metrics(&self) -> &crate::types::Metrics {
        &self.metrics
    }

    /// Reset metrics to zero (useful for testing or restarting simulation)
    pub fn reset_metrics(&mut self) {
        self.metrics = crate::types::Metrics::new();
    }
}

impl<D: QueueDiscipline> OrderBookEngine for OrderBook<D> {
    fn place(&mut self, order: Order) -> EngineResult<Vec<Trade>> {
        use crate::logging::{log_order_operation, log_trade, log_engine_error};
        
        let order_id = order.id;
        let start_time = Instant::now();
        
        // Validate the order
        if let Err(e) = self.validate_order(&order) {
            log_engine_error(&e, Some(&format!("Order {} validation", order_id)));
            
            // Record failed order in performance metrics
            if let Some(ref perf_metrics) = self.perf_metrics {
                perf_metrics.record_order_placement(start_time.elapsed(), false);
            }
            
            return Err(e);
        }

        // Process based on order type
        let result = match order.order_type {
            OrderType::Limit { price } => {
                log_order_operation("PLACE_LIMIT", order_id, Some(&format!("{:?} {} @ {}", order.side, order.qty, price)));
                self.process_limit_order(order, price)
            },
            OrderType::Market => {
                log_order_operation("PLACE_MARKET", order_id, Some(&format!("{:?} {}", order.side, order.qty)));
                self.process_market_order(order)
            },
        };

        let processing_time = start_time.elapsed();
        
        match &result {
            Ok(trades) => {
                // Record successful order in performance metrics
                if let Some(ref perf_metrics) = self.perf_metrics {
                    perf_metrics.record_order_placement(processing_time, true);
                    perf_metrics.record_trade(trades.len());
                }
                
                if trades.is_empty() {
                    log_order_operation("PLACED_NO_FILL", order_id, Some(&format!("Processing time: {:?}", processing_time)));
                } else {
                    log_order_operation("PLACED_WITH_FILLS", order_id, Some(&format!("{} trades, Processing time: {:?}", trades.len(), processing_time)));
                    
                    // Log each trade
                    for trade in trades {
                        log_trade(trade.maker_id, trade.taker_id, trade.price, trade.qty, trade.ts);
                    }
                }
            }
            Err(e) => {
                // Record failed order in performance metrics
                if let Some(ref perf_metrics) = self.perf_metrics {
                    perf_metrics.record_order_placement(processing_time, false);
                }
                
                log_engine_error(e, Some(&format!("Order {} placement failed after {:?}", order_id, processing_time)));
            }
        }

        result
    }

    fn cancel(&mut self, order_id: OrderId) -> EngineResult<Qty> {
        use crate::logging::{log_order_operation, log_engine_error};
        
        let start_time = Instant::now();
        
        // Look up order in index
        let (side, price) = match self.order_index.remove(&order_id) {
            Some(location) => {
                log_order_operation("CANCEL_LOOKUP_SUCCESS", order_id, Some(&format!("{:?} @ {}", location.0, location.1)));
                location
            }
            None => {
                let error = EngineError::UnknownOrder { order_id };
                log_engine_error(&error, Some("Order cancellation lookup"));
                
                // Record failed cancellation in performance metrics
                if let Some(ref perf_metrics) = self.perf_metrics {
                    perf_metrics.record_order_cancellation(start_time.elapsed(), false);
                }
                
                return Err(error);
            }
        };

        // Cancel from appropriate side
        let cancelled_qty = match side {
            Side::Buy => {
                let level = match self.bids.get_mut(&Reverse(price)) {
                    Some(level) => level,
                    None => {
                        // Restore order index entry since we failed
                        self.order_index.insert(order_id, (side, price));
                        let error = EngineError::internal("Order index inconsistency: bid level not found");
                        log_engine_error(&error, Some(&format!("Order {} cancel", order_id)));
                        
                        // Record failed cancellation in performance metrics
                        if let Some(ref perf_metrics) = self.perf_metrics {
                            perf_metrics.record_order_cancellation(start_time.elapsed(), false);
                        }
                        
                        return Err(error);
                    }
                };
                
                let qty = level.cancel(order_id);
                
                // Remove level if empty
                if level.is_empty() {
                    self.bids.remove(&Reverse(price));
                    log_order_operation("LEVEL_REMOVED", order_id, Some(&format!("Bid level @ {} now empty", price)));
                }
                
                qty
            }
            Side::Sell => {
                let level = match self.asks.get_mut(&price) {
                    Some(level) => level,
                    None => {
                        // Restore order index entry since we failed
                        self.order_index.insert(order_id, (side, price));
                        let error = EngineError::internal("Order index inconsistency: ask level not found");
                        log_engine_error(&error, Some(&format!("Order {} cancel", order_id)));
                        
                        // Record failed cancellation in performance metrics
                        if let Some(ref perf_metrics) = self.perf_metrics {
                            perf_metrics.record_order_cancellation(start_time.elapsed(), false);
                        }
                        
                        return Err(error);
                    }
                };
                
                let qty = level.cancel(order_id);
                
                // Remove level if empty
                if level.is_empty() {
                    self.asks.remove(&price);
                    log_order_operation("LEVEL_REMOVED", order_id, Some(&format!("Ask level @ {} now empty", price)));
                }
                
                qty
            }
        };

        let processing_time = start_time.elapsed();

        if cancelled_qty == 0 {
            let error = EngineError::UnknownOrder { order_id };
            log_engine_error(&error, Some(&format!("Order found in index but not in level after {:?}", processing_time)));
            
            // Record failed cancellation in performance metrics
            if let Some(ref perf_metrics) = self.perf_metrics {
                perf_metrics.record_order_cancellation(processing_time, false);
            }
            
            return Err(error);
        }

        // Record successful cancellation in performance metrics
        if let Some(ref perf_metrics) = self.perf_metrics {
            perf_metrics.record_order_cancellation(processing_time, true);
        }

        log_order_operation("CANCELLED", order_id, Some(&format!("Qty: {}, Processing time: {:?}", cancelled_qty, processing_time)));
        Ok(cancelled_qty)
    }

    fn best_bid(&self) -> Option<Price> {
        self.bids.keys().next().map(|reverse_price| reverse_price.0)
    }

    fn best_ask(&self) -> Option<Price> {
        self.asks.keys().next().copied()
    }

    fn depth_at(&self, side: Side, price: Price) -> Qty {
        match side {
            Side::Buy => {
                self.bids.get(&Reverse(price))
                    .map(|level| level.total_qty())
                    .unwrap_or(0)
            }
            Side::Sell => {
                self.asks.get(&price)
                    .map(|level| level.total_qty())
                    .unwrap_or(0)
            }
        }
    }

    fn snapshot(&self) -> DepthSnapshot {
        let start_time = Instant::now();
        
        let ts = now_ns();
        let best_bid = self.best_bid();
        let best_ask = self.best_ask();
        let spread = self.spread();
        let mid = self.mid_price();

        // Collect bid levels (already in descending price order)
        let bids: Vec<BookLevelPoint> = self.bids
            .iter()
            .map(|(reverse_price, level)| BookLevelPoint {
                price: reverse_price.0,
                qty: level.total_qty(),
                latency_ms: self.calculate_latency_ms(level.last_ts()),
            })
            .collect();

        // Collect ask levels (already in ascending price order)
        let asks: Vec<BookLevelPoint> = self.asks
            .iter()
            .map(|(price, level)| BookLevelPoint {
                price: *price,
                qty: level.total_qty(),
                latency_ms: self.calculate_latency_ms(level.last_ts()),
            })
            .collect();

        let snapshot = DepthSnapshot {
            ts,
            best_bid,
            best_ask,
            spread,
            mid,
            bids,
            asks,
            recent_spreads: self.get_recent_spreads(),
            metrics: self.metrics.clone(),
        };

        // Record snapshot generation time in performance metrics
        if let Some(ref perf_metrics) = self.perf_metrics {
            perf_metrics.record_snapshot_generation(start_time.elapsed());
        }

        snapshot
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::queue_fifo::FifoLevel;
    use crate::types::{OrderType, Side};
    use crate::time::now_ns;

    type TestOrderBook = OrderBook<FifoLevel>;

    fn create_test_order(id: OrderId, side: Side, qty: Qty, order_type: OrderType) -> Order {
        Order {
            id,
            side,
            qty,
            order_type,
            ts: now_ns(),
        }
    }

    #[test]
    fn test_order_book_creation() {
        let book = TestOrderBook::new();
        assert_eq!(book.best_bid(), None);
        assert_eq!(book.best_ask(), None);
        assert_eq!(book.spread(), None);
        assert_eq!(book.mid_price(), None);
    }

    #[test]
    fn test_place_limit_orders() {
        let mut book = TestOrderBook::new();
        
        // Place a buy order (price 50.00 = 500000 ticks)
        let buy_order = create_test_order(1, Side::Buy, 100, OrderType::Limit { price: 500000 });
        let trades = book.place(buy_order).unwrap();
        assert!(trades.is_empty()); // No crossing
        assert_eq!(book.best_bid(), Some(500000));
        assert_eq!(book.best_ask(), None);
        
        // Place a sell order at higher price (no crossing) (price 51.00 = 510000 ticks)
        let sell_order = create_test_order(2, Side::Sell, 200, OrderType::Limit { price: 510000 });
        let trades = book.place(sell_order).unwrap();
        assert!(trades.is_empty()); // No crossing
        assert_eq!(book.best_bid(), Some(500000));
        assert_eq!(book.best_ask(), Some(510000));
        assert_eq!(book.spread(), Some(10000)); // 1.00 in ticks
        assert_eq!(book.mid_price(), Some(50.5));
    }

    #[test]
    fn test_order_crossing() {
        let mut book = TestOrderBook::new();
        
        // Place a buy order
        let buy_order = create_test_order(1, Side::Buy, 100, OrderType::Limit { price: 500000 });
        book.place(buy_order).unwrap();
        
        // Place a sell order that crosses
        let sell_order = create_test_order(2, Side::Sell, 50, OrderType::Limit { price: 495000 });
        let trades = book.place(sell_order).unwrap();
        
        // Should generate one trade
        assert_eq!(trades.len(), 1);
        assert_eq!(trades[0].maker_id, 1);
        assert_eq!(trades[0].taker_id, 2);
        assert_eq!(trades[0].price, 500000); // Trade at maker's price
        assert_eq!(trades[0].qty, 50);
        
        // Buy order should have 50 remaining
        assert_eq!(book.depth_at(Side::Buy, 500000), 50);
        assert_eq!(book.depth_at(Side::Sell, 495000), 0); // Sell order fully filled
    }

    #[test]
    fn test_market_order_buy() {
        let mut book = TestOrderBook::new();
        
        // Place some sell orders
        let sell1 = create_test_order(1, Side::Sell, 100, OrderType::Limit { price: 500000 });
        let sell2 = create_test_order(2, Side::Sell, 200, OrderType::Limit { price: 510000 });
        book.place(sell1).unwrap();
        book.place(sell2).unwrap();
        
        // Place market buy order
        let market_buy = create_test_order(3, Side::Buy, 150, OrderType::Market);
        let trades = book.place(market_buy).unwrap();
        
        // Should generate 2 trades
        assert_eq!(trades.len(), 2);
        
        // First trade at 500000 for 100 shares
        assert_eq!(trades[0].maker_id, 1);
        assert_eq!(trades[0].taker_id, 3);
        assert_eq!(trades[0].price, 500000);
        assert_eq!(trades[0].qty, 100);
        
        // Second trade at 510000 for 50 shares
        assert_eq!(trades[1].maker_id, 2);
        assert_eq!(trades[1].taker_id, 3);
        assert_eq!(trades[1].price, 510000);
        assert_eq!(trades[1].qty, 50);
        
        // Check remaining quantities
        assert_eq!(book.depth_at(Side::Sell, 500000), 0); // First level consumed
        assert_eq!(book.depth_at(Side::Sell, 510000), 150); // 200 - 50 = 150 remaining
        assert_eq!(book.best_ask(), Some(510000));
    }

    #[test]
    fn test_market_order_no_liquidity() {
        let mut book = TestOrderBook::new();
        
        // Try to place market buy with no asks
        let market_buy = create_test_order(1, Side::Buy, 100, OrderType::Market);
        let result = book.place(market_buy);
        
        assert!(matches!(result, Err(EngineError::NoLiquidity)));
    }

    #[test]
    fn test_order_cancellation() {
        let mut book = TestOrderBook::new();
        
        // Place some orders
        let buy1 = create_test_order(1, Side::Buy, 100, OrderType::Limit { price: 500000 });
        let buy2 = create_test_order(2, Side::Buy, 200, OrderType::Limit { price: 495000 });
        let sell1 = create_test_order(3, Side::Sell, 150, OrderType::Limit { price: 510000 });
        
        book.place(buy1).unwrap();
        book.place(buy2).unwrap();
        book.place(sell1).unwrap();
        
        // Cancel middle buy order
        let cancelled_qty = book.cancel(2).unwrap();
        assert_eq!(cancelled_qty, 200);
        
        // Check that best bid is now the remaining order
        assert_eq!(book.best_bid(), Some(500000));
        assert_eq!(book.depth_at(Side::Buy, 495000), 0);
        assert_eq!(book.depth_at(Side::Buy, 500000), 100);
        
        // Try to cancel non-existent order
        let result = book.cancel(999);
        assert!(matches!(result, Err(EngineError::UnknownOrder { order_id: 999 })));
    }

    #[test]
    fn test_order_validation() {
        let mut book = TestOrderBook::new();
        
        // Test zero quantity
        let zero_qty_order = create_test_order(1, Side::Buy, 0, OrderType::Limit { price: 500000 });
        let result = book.place(zero_qty_order);
        assert!(matches!(result, Err(EngineError::InvalidQty { qty: 0 })));
        
        // Test zero price for limit order
        let zero_price_order = create_test_order(2, Side::Buy, 100, OrderType::Limit { price: 0 });
        let result = book.place(zero_price_order);
        assert!(matches!(result, Err(EngineError::InvalidPrice { price: 0 })));
        
        // Test duplicate order ID
        let order1 = create_test_order(3, Side::Buy, 100, OrderType::Limit { price: 500000 });
        let order2 = create_test_order(3, Side::Sell, 200, OrderType::Limit { price: 510000 });
        
        book.place(order1).unwrap();
        let result = book.place(order2);
        assert!(matches!(result, Err(EngineError::Reject { .. })));
    }

    #[test]
    fn test_depth_snapshot() {
        let mut book = TestOrderBook::new();
        
        // Place orders on both sides (using proper tick values)
        let buy1 = create_test_order(1, Side::Buy, 100, OrderType::Limit { price: 500000 }); // $50.00
        let buy2 = create_test_order(2, Side::Buy, 200, OrderType::Limit { price: 495000 }); // $49.50
        let sell1 = create_test_order(3, Side::Sell, 150, OrderType::Limit { price: 510000 }); // $51.00
        let sell2 = create_test_order(4, Side::Sell, 300, OrderType::Limit { price: 520000 }); // $52.00
        
        book.place(buy1).unwrap();
        book.place(buy2).unwrap();
        book.place(sell1).unwrap();
        book.place(sell2).unwrap();
        
        let snapshot = book.snapshot();
        
        // Check basic market data
        assert_eq!(snapshot.best_bid, Some(500000));
        assert_eq!(snapshot.best_ask, Some(510000));
        assert_eq!(snapshot.spread, Some(10000)); // $1.00 in ticks
        assert_eq!(snapshot.mid, Some(50.5));
        
        // Check bid levels (should be in descending price order)
        assert_eq!(snapshot.bids.len(), 2);
        assert_eq!(snapshot.bids[0].price, 500000);
        assert_eq!(snapshot.bids[0].qty, 100);
        assert_eq!(snapshot.bids[1].price, 495000);
        assert_eq!(snapshot.bids[1].qty, 200);
        
        // Check ask levels (should be in ascending price order)
        assert_eq!(snapshot.asks.len(), 2);
        assert_eq!(snapshot.asks[0].price, 510000);
        assert_eq!(snapshot.asks[0].qty, 150);
        assert_eq!(snapshot.asks[1].price, 520000);
        assert_eq!(snapshot.asks[1].qty, 300);
        
        // Check that snapshot includes new fields
        assert!(snapshot.recent_spreads.is_empty()); // No trades yet, so no spread history
        assert_eq!(snapshot.metrics.inventory, 0);
        assert_eq!(snapshot.metrics.cash, 0);
        assert_eq!(snapshot.metrics.pnl, 0);
        
        // Check latency information is included (latency_ms is u64, so always >= 0)
        // Just verify the field exists and is a reasonable value
        assert!(snapshot.bids[0].latency_ms < 1000000); // Less than 1000 seconds
        assert!(snapshot.asks[0].latency_ms < 1000000);
    }

    #[test]
    fn test_spread_history_tracking() {
        let mut book = TestOrderBook::new();
        
        // Place initial orders to establish spread
        let buy1 = create_test_order(1, Side::Buy, 100, OrderType::Limit { price: 500000 });
        let sell1 = create_test_order(2, Side::Sell, 100, OrderType::Limit { price: 510000 });
        
        book.place(buy1).unwrap();
        book.place(sell1).unwrap();
        
        // Execute a trade to trigger spread history update
        let market_buy = create_test_order(3, Side::Buy, 50, OrderType::Market);
        book.place(market_buy).unwrap();
        
        let snapshot = book.snapshot();
        
        // Should have at least one spread entry after the trade
        assert!(!snapshot.recent_spreads.is_empty());
        
        // The spread should be recorded
        let (ts, spread) = snapshot.recent_spreads[0];
        assert!(ts > 0);
        assert_eq!(spread, 10000); // $1.00 spread in ticks
    }

    #[test]
    fn test_metrics_tracking() {
        let mut book = TestOrderBook::new();
        
        // Place orders
        let sell1 = create_test_order(1, Side::Sell, 100, OrderType::Limit { price: 500000 });
        let buy1 = create_test_order(2, Side::Buy, 200, OrderType::Limit { price: 495000 });
        
        book.place(sell1).unwrap();
        book.place(buy1).unwrap();
        
        // Execute a market buy that will trade against the sell order
        let market_buy = create_test_order(3, Side::Buy, 50, OrderType::Market);
        let trades = book.place(market_buy).unwrap();
        
        assert_eq!(trades.len(), 1);
        assert_eq!(trades[0].qty, 50);
        assert_eq!(trades[0].price, 500000);
        
        let snapshot = book.snapshot();
        
        // Check that metrics were updated for the buy trade
        assert_eq!(snapshot.metrics.inventory, 50); // Bought 50 shares
        assert_eq!(snapshot.metrics.cash, -25000000); // Paid 50 * 500000 ticks
        
        // PnL should be calculated (inventory * mid_price + cash)
        // Mid price should be around 497500 (between 495000 and 500000)
        assert!(snapshot.metrics.pnl != 0);
    }

    #[test]
    fn test_metrics_multiple_trades() {
        let mut book = TestOrderBook::new();
        
        // Place orders on both sides
        let sell1 = create_test_order(1, Side::Sell, 100, OrderType::Limit { price: 500000 });
        let sell2 = create_test_order(2, Side::Sell, 100, OrderType::Limit { price: 510000 });
        let buy1 = create_test_order(3, Side::Buy, 100, OrderType::Limit { price: 490000 });
        
        book.place(sell1).unwrap();
        book.place(sell2).unwrap();
        book.place(buy1).unwrap();
        
        // Execute multiple trades
        let market_buy1 = create_test_order(4, Side::Buy, 50, OrderType::Market);
        let market_buy2 = create_test_order(5, Side::Buy, 30, OrderType::Market);
        let market_sell1 = create_test_order(6, Side::Sell, 40, OrderType::Market);
        
        book.place(market_buy1).unwrap(); // Buy 50 at 500000
        book.place(market_buy2).unwrap(); // Buy 30 at 500000
        book.place(market_sell1).unwrap(); // Sell 40 at 490000
        
        let snapshot = book.snapshot();
        
        // Net inventory: +50 +30 -40 = +40
        assert_eq!(snapshot.metrics.inventory, 40);
        
        // Net cash: -(50*500000) -(30*500000) +(40*490000)
        let expected_cash = -(50 * 500000) - (30 * 500000) + (40 * 490000);
        assert_eq!(snapshot.metrics.cash, expected_cash);
    }

    #[test]
    fn test_latency_calculation() {
        let mut book = TestOrderBook::new();
        
        // Place an order and immediately take snapshot
        let order = create_test_order(1, Side::Buy, 100, OrderType::Limit { price: 500000 });
        book.place(order).unwrap();
        
        let snapshot1 = book.snapshot();
        assert_eq!(snapshot1.bids.len(), 1);
        let initial_latency = snapshot1.bids[0].latency_ms;
        
        // Wait a bit and take another snapshot
        std::thread::sleep(std::time::Duration::from_millis(10));
        
        let snapshot2 = book.snapshot();
        let later_latency = snapshot2.bids[0].latency_ms;
        
        // Latency should have increased
        assert!(later_latency >= initial_latency);
    }

    #[test]
    fn test_spread_history_bounded() {
        let mut book = TestOrderBook::new();
        
        // Place orders to establish spread
        let sell1 = create_test_order(1, Side::Sell, 1000, OrderType::Limit { price: 500000 });
        book.place(sell1).unwrap();
        
        // Execute many trades to test history bounding
        for i in 0..450 {
            let market_buy = create_test_order(100 + i, Side::Buy, 1, OrderType::Market);
            book.place(market_buy).unwrap();
        }
        
        let snapshot = book.snapshot();
        
        // Should be bounded to 400 entries
        assert!(snapshot.recent_spreads.len() <= 400);
    }

    #[test]
    fn test_metrics_reset() {
        let mut book = TestOrderBook::new();
        
        // Execute some trades
        let sell1 = create_test_order(1, Side::Sell, 100, OrderType::Limit { price: 500000 });
        book.place(sell1).unwrap();
        
        let market_buy = create_test_order(2, Side::Buy, 50, OrderType::Market);
        book.place(market_buy).unwrap();
        
        // Verify metrics are non-zero
        let metrics_before = book.get_metrics();
        assert_ne!(metrics_before.inventory, 0);
        assert_ne!(metrics_before.cash, 0);
        
        // Reset metrics
        book.reset_metrics();
        
        // Verify metrics are reset
        let metrics_after = book.get_metrics();
        assert_eq!(metrics_after.inventory, 0);
        assert_eq!(metrics_after.cash, 0);
        assert_eq!(metrics_after.pnl, 0);
    }

    #[test]
    fn test_multiple_level_crossing() {
        let mut book = TestOrderBook::new();
        
        // Place multiple ask levels
        let sell1 = create_test_order(1, Side::Sell, 100, OrderType::Limit { price: 500000 });
        let sell2 = create_test_order(2, Side::Sell, 200, OrderType::Limit { price: 510000 });
        let sell3 = create_test_order(3, Side::Sell, 150, OrderType::Limit { price: 520000 });
        
        book.place(sell1).unwrap();
        book.place(sell2).unwrap();
        book.place(sell3).unwrap();
        
        // Place large buy order that crosses multiple levels
        let big_buy = create_test_order(4, Side::Buy, 250, OrderType::Limit { price: 515000 });
        let trades = book.place(big_buy).unwrap();
        
        // Should generate 2 trades (crosses first two levels)
        assert_eq!(trades.len(), 2);
        
        // First trade at 500000 for 100 shares
        assert_eq!(trades[0].price, 500000);
        assert_eq!(trades[0].qty, 100);
        
        // Second trade at 510000 for 150 shares (remaining taker qty)
        assert_eq!(trades[1].price, 510000);
        assert_eq!(trades[1].qty, 150);
        
        // Check remaining state
        assert_eq!(book.depth_at(Side::Sell, 500000), 0); // Fully consumed
        assert_eq!(book.depth_at(Side::Sell, 510000), 50); // 200 - 150 = 50 remaining
        assert_eq!(book.depth_at(Side::Sell, 520000), 150); // Untouched
        assert_eq!(book.best_ask(), Some(510000));
    }
}